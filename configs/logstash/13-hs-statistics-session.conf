filter {

  # yesterdays-variables.log
  if [logname] == "yesterdays-variables" {
    csv {
      columns => ["date_string","usr_id","session_id","session_name","session_type","session_value"]
      separator => ","
    }
    # drop if header
    if [date_string] == "timestamp" {
      drop { }
    } 
    date {
        match => [ "date_string", "yyyy-MM-dd HH:mm:ss.SSSSSSZZ"]
        target => "session_timestamp"
    }
    mutate {
      convert => {
        "usr_id" => "integer"
        "session_id" => "integer"
      }
      remove_field => ["date_string"]
    }
  }

  # activity.log
  if [logname] == "activity" {
   
    # extract the timestamp from the message
    grok {
      match => {"message" => "%{TIMESTAMP_ISO8601:date_string} %{GREEDYDATA:log_message}"}
    }
    date {
        match => [ "date_string", "yyyy-MM-dd HH:mm:ss.SSSSSSZZ"]
        target => "session_timestamp"
    }
     
    # extract the key value pairs from the log_message
    kv {
      source => "log_message"
    } 
   
    mutate {
      convert => {
        "usr_id" => "integer"
        "session_id" => "integer"
      }
      remove_field => ["date_string"]
    }

    # parse dns
    geoip {
      source => [ "user_ip" ]
    }

    # The DNS plugin doesn't allow a "target" argument, so we have to copy the field unless we want to overwrite the ip
    mutate {
      add_field => { "client_host" => "%{user_ip}" }
    }

    dns {
      reverse => [ "client_host" ]
      action => "replace"
      hit_cache_size => 200
      failed_cache_size => 200
      failed_cache_ttl => 30
      max_retries => 1
    }

    if [user_ip] == [client_host] {
      mutate {
        remove_field => [ "client_host" ]
      }
    }

    # Parse out top level edu domains (xxx.school.edu => school.edu, yyy.school.edu => school.edu)
    grok {
      match => { "client_host" => "(?<edu_domain>[^\.]*\.edu)$" }
      tag_on_failure => [ ]
    }

  }
}

